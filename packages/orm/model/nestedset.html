<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="./../../../assets/css/combined.css">
	<link rel="shortcut icon" href="./../../../favicon.ico" />
	<script src="http://www.google.com/jsapi" type="text/javascript"></script>
	<script type="text/javascript">
		var path = './../../../';
		var class_prefix = "Model_Nestedset::";
	</script>
	<script src="./../../../assets/js/combined.js"></script>
	<title>NestedSets Model - Orm パッケージ - FuelPHP ドキュメント</title>
</head>
<body>
	<div id="container">
		<header id="header">
			<div class="table">
				<h1>
					<strong>FuelPHP, a PHP 5.3 Framework</strong>
					Documentation
				</h1>

				<form id="google_search">
					<p>
						<span id="search_clear">&nbsp;</span>
						<input type="submit" name="search_submit" id="search_submit" value="検索" />
						<input type="text" value="" id="search_input" name="search_input" />
					</p>
				</form>
			</div>
			<nav>

				<div class="clear"></div>
			</nav>
			<a href="#" id="toc_handle">目次</a>
			<div class="clear"></div>
		</header>

		<div id="cse">
			<div id="cse_point"></div>
			<div id="cse_content"></div>
		</div>

            <div id="main">
                <section>
                    <h2 id="introduction">はじめに</h2>

					<p>
						<i>以下の解説は <a href="http://www.codeproject.com/Articles/4155/Improve-hierarchy-performance-using-nested-sets">この記事</a>（(c) James Simpson）にもとづいています。</i>
					</p>
                    <p>
						入れ子集合モデルは、リレーショナルデータベースにおける入れ子集合 (ツリーや階層構造と言ってもいいです)を実現する方法の1つです。
						この用語はJoe Celkoによって紹介されたものだと言われていますが、同じテクニックが特に名前を付けられることもないまま、あるいは別の名前によって
						語られることもあります。(<a href="http://en.wikipedia.org/wiki/Nested_set_model">Source: Wikipedia</a>)
					</p>
					<p>
						よくあるツリー構造の例は、組織の構造図です。この例を使って、入れ子集合がどのような働きをするかを説明していきます。
                    </p>

                    <div class="image">
						<img src="./../../../assets/img/nestedset.gif" alt="入れ子集合の視覚化" />
                    </div>

					<p>
						上図は各ノードがそれぞれの子孫全てについて把握していて、その逆もまた真であることを示しています。例えば、この図からは
						BenとAngelaがBillの「子」であることが容易に見てとれます。 また、TimとJamesがBenの「子」であることも分かります。
						これは詰まるところ、階層構造の中の各要素間のつながりを示しているものです。
					</p>
					<p>
						この構造を表現するためには、各ノードにおいて2つの値を余分に保存する必要があり、これによってツリー構造内の
						ノード間のつながりを定めます。図の中では青と赤で示しています。これら左側の値(<span style="color:red;">赤</span>の値)と
						右側の値(<span style="color:blue;">青</span>の値)を、ポインターと呼びます。
						ポインターをテーブル上に保存するだけで、入れ子集合による階層構造を完全に表現することができます。
					</p>

					<p>
						数学の好きな人なら、ツリー構造は別の形で図示することもできるということを知っている筈です。
					</p>

                    <div class="image">
						<img src="./../../../assets/img/nestedset2.gif" alt="nested set visual" />
                    </div>

                    <p>
						一見するとよく分からないかもしれませんが、というかおそらく余計に読み難く感じるとは思うのですが、このように表せば何故これが
						入れ子集合と呼ばれるのか、また何故この形で階層的なデータを平面的なテーブル上へ格納するのが効率的なのかは、一目瞭然となります。
						親子間の関連性はパッと見で分かり（全ての子が親の中に含まれています）、またそれぞれのノードは自身の親や、そして自身の全ての
						子孫について把握しています。この形で構造を表すことによって、全てのポインタが美しく並んでいることがはっきり分かるようになります。このことは
						ツリー構造へアクセスする必要がある際に、非常に便利なものとなります
                    </p>

					<h3>単一のテーブルで複数のツリー構造を保存する</h3>

					<p>
						単一のテーブルで複数のツリー構造を保存することもできます。これを可能とするために、ツリーのIDを
						テーブルのカラムに追加することもできます。ツリーIDがあれば、ノードがどのツリーのものかを識別することができます。
					</p>
					<p>
						ツリーIDには整数値でも文字列でも使えるのですが、整数値であれば、ツリーを新しく作る際に自動生成させることもできます。
						整数値ならツリーIDを1対他のリレーションでの外部キーとして使うことも容易となり、DB内でのインデックスのルックアップも
						より高速になります。なるべく文字列をツリーIDに使うことはしない方がよいです。
					</p>

					<h3>テーブル構造</h3>

					<p>
						テーブルには必要とするだけ幾つでもカラムを追加できますが、ちゃんと動かすためには、入れ子集合モデルには最低限必要な
						カラムが幾つかあります。
					</p>

					<ul>
						<li>左ノードポインター、デフォルトのカラム名は「left_id」</li>
						<li>右ノードポインター、デフォルトのカラム名は「right_id」</li>
						<li>ツリーID、テーブル内に複数のツリーを含む場合のみ必須（デフォルトでは必要ありません）</li>
					</ul>
					<p>
						実際のカラム名は、モデル内で設定することができます。厳密に言うと必要というわけではないのですが、
						幾つかのメソッドは「title」や「name」というフィールドを使います。これらのカラム名もまたモデル内で設定することができます。
						もしこれらのフィールドを要求するメソッドを使う際、フィールドが定義されていなければ、例外が投げられます。
					</p>
					<p>
						以下は入れ子集合テーブルの最小構成です。
					</p>

                    <pre class="php"><code>CREATE TABLE `tree` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `left_id` int(11) unsigned NOT NULL,
  `right_id` int(11) unsigned NOT NULL,
  `tree_id` int(11) unsigned NOT NULL,
  `name` varchar(50),
  PRIMARY KEY (`id`),
  KEY `left_id` (`left_id`),        // optional, might speed up certain lookups
  KEY `right_id` (`right_id`),      // optional, might speed up certain lookups
)
</code></pre>
                </section>

                <section>
                    <h2 id="configuration">設定</h2>

                    <p>Nestedsetモデルでは追加のプロパティとして<kbd>$_tree</kbd>が加わり、これによってそのモデルの設定をすることができます。</p>
                    <ul>
						<li><kbd>left_field</kbd> はテーブルのカラム名を定義するもので、ツリーの<strong>左ポインター</strong>を格納するのに使われます。デフォルトのカラム名は「left_id」です。</li>
						<li><kbd>right_field</kbd> はテーブルのカラム名を定義するもので、ツリーの<strong>右ポインター</strong>を格納するのに使われます。デフォルトのカラム名は「right_id」です。</li>
						<li><kbd>tree_field</kbd> はテーブルのカラム名を定義するもので、ツリーの<strong>ID</strong>、つまり複数のツリー構造を単一のテーブルへ格納するときに
							各ツリーを一意に識別する値を格納するのに使われます。ツリーIDに数値を使う場合は、新たなツリーのルートノードを作る際に、モデルへ自動的にこの値を
							割り当てさせることができます。数値でない場合は、<kbd>save()</kbd>を呼ぶ前に自分でその値を与えてやる必要があります。デフォルトの値はありません。</li>
						<li><kbd>title_field</kbd>はテーブルのカラム名を定義するもので、ツリーのノードの<strong>タイトル</strong>や<strong>名前</strong>を格納するのに使われます。これは任意のもので、
							なくても入れ子集合モデルは十分機能するのですが、このモデルの幾つかのメソッドにおいては要求されます。どこで適用されるのかについては、当該メソッドについてのドキュメントで
							言及しています。デフォルトの値はありません。</li>
                    </ul>
                    <p>次の節では基本的なNestedsetモデルがどのようなものなのか、またどのように設定するのかを示します。</p>
                </section>

                <section>
                    <h2 id="model">モデルの定義</h2>

                    <p>
						入れ子集合モデルの利用は簡単で、<kbd>\Orm\Model</kbd>のかわりに<kbd>\Orm\Model_Nestedset</kbd>を継承するだけです。
						これによってあなたのモデルは入れ子集合モデルとなり、ツリーやノードを扱うための沢山のメソッドが追加され、また
						また <kbd>delete()</kbd> や <kbd>save()</kbd> メソッドのデフォルトの挙動が変わることで、ツリー構造がきちんと一貫性を保てるようになります。
					</p>

                    <pre class="php"><code>&lt;?php
class Model_Tree extends \Orm\Model_Nestedset
{
	/**
	* @var  string  name of the table to be used by this model
	*/
    protected static $_table_name = 'tree';

	/**
	 * @var  array  array of object properties
	 */
    protected static $_properties = array(
		'id',
		'left_id',
		'right_id',
		'tree_id',
		'name',
    );

	/**
	 * @var  array  array with the tree configuration
	 */
    protected static $_tree = array(
		'left_field'     =&gt; 'left_id',		// name of the tree node left index field
		'right_field'    =&gt; 'right_id',		// name of the tree node right index field
		'tree_field'     =&gt; 'tree_id',		// name of the tree node tree index field
		'title_field'    =&gt; 'name',		//  name of the tree node title field
    );

}
?&gt;</code></pre>
                    <p>
						見ての通り、まったく標準的な ORM モデルの設定です。 唯一追加されたクラスプロパティが <strong>$_tree</strong> で、これは
						ツリーの設定を定義するものとなります。このモデルはこの設定から通常の<a href="../creating_models.html">ORM モデル</a>と同様に構築され、いかなるリレーションや
						他のプロパティも思うままに使うことができます。
					</p>

                </section>

                <section>
                    <h2 id="usage">モデルの使用法</h2>

					<p>
						最初に挙げた組織構成図の例と先ほど定義したモデルを使って、そのツリー構造を作ることからやってみましょう。
					</p>
                    <pre class="php"><code>&lt;?php
// Bill, our MD, is the root of the tree
$bill = Model_Tree::forge(array('name' => 'Bill'));

// if you save a new node, it will automatically become a tree root node
$bill->save();

// give our MD some subordinates
$angela = Model_Tree::forge(array('name' => 'Angela'));
$ben = Model_Tree::forge(array('name' => 'Ben'));

// they are children of Bill in the tree
$angela->child($bill)->save();
$ben->child($bill)->save();

// add the rest of Customer service
$henry = Model_Tree::forge(array('name' => 'Henry'));
$henry->child($angela)->save();
$nicola = Model_Tree::forge(array('name' => 'Nicola'));
$nicola->child($angela)->save();

// and the development team
$kerry = Model_Tree::forge(array('name' => 'Kerry'));
$kerry->child($ben)->save();
// a sibling of Kerry is a child of Ben too...
$james = Model_Tree::forge(array('name' => 'James'));
$james->sibling($kerry)->save();

// assign the teams benjamin to Kerry
$tim = Model_Tree::forge(array('name' => 'Tim'));
$tim->child($kerry)->save();
?&gt;</code></pre>

					<p>
						見ての通り、ツリー構造の作成とノードの追加はいい感じに簡単なものです。Nestedset モデルと他の ORM モデルとの間にある
						主な違いは、モデルの他のオブジェクトに対して影響するメソッドを持つかどうか、という点にあります。単に問い合わせをそのモデルに対して
						行ったり、あるオブジェクトを保存するというのではなく、ツリー構造内の別のオブジェクトに対してそれらのことを行う、ということです。これは
						従来通りのメソッドが使えないという意味ではなく、<kbd>Model::find()</kbd> や <kbd>Model::query()</kbd> なども依然、他の ORM モデルと同様に使うことができます。
					</p>
					<p>
						それでは次はこのツリー構造から情報を得たり、ツリー構造を操作したりするのに使えるメソッドの説明へ
						進みましょう。
					</p>
                </section>

                <section>
					<h2 id="behavioral_changes">行動変化</h2>

					<p>
						In addition to the primary key, which is read-only in every ORM model object once set, a Nestedset model doesn't allow
						you to make	changes to the left- and right pointers of the node, and to the tree-id if defined. Attempting to do so, either
						via assigment, using a call to <kbd>set()</kbd> or by using <kbd>unset()</kbd>, will result in a <strong>InvalidArgumentException</strong>.
					</p>

					<article>
						<h4 id="method_save" class="method">save($cascade = null, $use_transaction = false)</h4>
						<p>
							The <kbd>save</kbd> method works exactly the same as the regular model's implementation.
						</p>
						<p>
							However, when you use this method on new tree node objects, additional functionality is added to make sure the tree structure
							stays consistent. When you call it on an object and you have used one of the collection methods documented below, the
							new object is inserted in the tree relative to the object passed to the collection method.
						</p>
						<p>
							If you haven't used a collection method, <kbd>save</kbd> will assume you want to insert a new root node. If the model is
							a multi-tree model, it will create a new root with the next available tree-id (if the id is numeric. If not, assign a new
							tree-id to the node object yourself).
						</p>
						<p class="note">
							 If a root node can not be created because one already exists, an <strong>OutOfBoundsException</strong> will be thrown. If
							 the tree-id is not numeric, and you haven't supplied one manually, the result is <strong><u>unpredicable</u></strong>!
						</p>
					</article>

					<article>
						<h4 id="method_delete" class="method">delete($cascade = null, $use_transaction = false)</h4>
						<p>
							The <kbd>delete</kbd> method works exactly the same as the regular model's implementation.
						</p>
						<p>
							If the node you delete is not a leaf node (i.e. is has children), all descendants of the node will move one level up in the
							tree, they will become descendants of the nodes parent. If you want to delete an entire (subsection of the) tree, use the
							<a href="#method_delete_tree">delete_tree()</a> method instead.
						</p>
						<p class="note">
							You can not use the <strong>delete()</strong> method on a root node if the root node has more then one child node.
							Doing so would create an inconsistent tree, as you can't have multiple nodes at the highest level. Trying do to so
							will throw a <strong>DomainException</strong>!
						</p>
					</article>

                </section>

                <section>
					<h2 id="collection_methods">コレクションメソッド</h2>

					<p>
						Collection methods are methods that allow you to perform an operation, either a <strong>get()</strong> or a <strong>save()</strong>,
						on a part of a nestedset tree. Some methods are available for both, some are only relevant for one. For clarity, they are documented
						seperately. Using a collection method on an operation that doesn't support it will cause an <strong>OutOfBoundsException</strong> to
						be thrown.
					</p>

					<h3 id="collection_methods_get">Collection methods for getting nodes</h3>

					<p>
						Like with standard ORM models, you can use the <strong>get()</strong> method to return an array of objects, and the
						<strong>get_one()</strong> method to return a single object. If a collection method is supposed to return a single result,
						like for example <strong>root()</strong>, <strong>get()</strong> will return an array with that single object. If
						a collection method returns multiple objects, like for example <strong>children()</strong>, <strong>get_one()</strong>
						will return the first object from the result set. It is undetermined which one that will be.<br />
						<strong>get()</strong> and <strong>get_one()</strong> return <strong>null</strong> if no result was found.
					</p>

					<article>
						<h4 id="method_get_root" class="method">root()</h4>
						<p>
							The <strong>root</strong> method allows you to get the root of the tree of the object you call this method on.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the root of the tree $henry belongs to
$root = $henry->root()->get_one();

// echos 'true'
echo $root == $bill ? 'true' : 'false';

// get the root of a specific tree
$root = Model_Tree::forge()->set_tree_id($mytreeid)->root()->get_one();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_get_roots" class="method">roots()</h4>
						<p>
							The <strong>roots</strong> method allows you to get all the root nodes. If the model is not a multi-tree model,
							only the one root node is returned.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get all roots in the tree
$roots = $henry->roots()->get();

// echos 'true' (there's only one root in the tree)
echo reset($roots) == $bill ? 'true' : 'false';

// get alls root without having an existing object
$roots = Model_Tree::forge()->roots()->get();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_get_parent" class="method">parent()</h4>
						<p>
							The <strong>parent</strong> method allows you to get the parent node of the object you call this method on.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the parent of $nicola
$parent = $nicola->parent()->get_one();

// echos 'true'
echo $parent == $angela ? 'true' : 'false';

// returns null, it won't work without a node tree context
$parent = Model_Tree::forge()->parent()->get_one();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_get_children" class="method">children()</h4>
						<p>
							The <strong>children</strong> method allows you to get all child nodes of the object you call this method on.
							Note that this returns only children, no grandchildren. If you are interested in the entire sub-tree, use
							the <a href="#method_get_descendants">descendants</a> method instead.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the children of $angela
$children = $angela->children()->get();

// echos 'true'
echo $children == array($henry->id => $henry, $nicola->id => $nicola) ? 'true' : 'false';

// returns null, it won't work without a current node context
$parent = Model_Tree::forge()->children()->get();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_get_ancestors" class="method">ancestors()</h4>
						<p>
							The <strong>ancestors</strong> method allows you to get all ancestor nodes of the object you call this method on.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the ancestors of $henry
$ancestors = $henry->children()->get();

// echos 'true'
echo $ancestors == array($bill->id => $bill, $angela->id => $angela) ? 'true' : 'false';

// returns null, it won't work without a current node context
$parent = Model_Tree::forge()->ancestors()->get();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
						<p class="note">
							Ancestors are returned in order of their position in the tree, with the root node first.
						</p>
					</article>

					<article>
						<h4 id="method_get_descendants" class="method">descendants()</h4>
						<p>
							The <strong>descendants</strong> method allows you to get all descendant nodes of the object you call this method on.
							This allows you to fetch an entire sub-tree.The result will NOT include the start node itself.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the descendants of $ben
$descendants = $ben->descendants()->get();

// echos 'true'
echo $descendants == array($kerry->id => $kerry, $tim->id => $tim, $james->id => $james) ? 'true' : 'false';

// returns null, it won't work without a current node context
$parent = Model_Tree::forge()->descendants()->get();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
						<p class="note">
							Descendants are returned in order of their position in the tree.
						</p>
					</article>

					<article>
						<h4 id="method_get_leaf_descendants" class="method">leaf_descendants()</h4>
						<p>
							The <strong>leaf_descendants</strong> method allows you to get leaf descendant nodes of the object you call this method on.
							Unlike the <a href="#method_get_descendants">descendants</a> method, this method only returns nodes that do not have
							children (the leafs of the tree).
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the leaf descendants of $ben
$descendants = $ben->leaf_descendants()->get();

// echos 'true'. Note that $kerry is not returned now, as that has a child object
echo $descendants == array($tim->id => $tim, $james->id => $james) ? 'true' : 'false';

// returns null, it won't work without a current node context
$parent = Model_Tree::forge()->leaf_descendants()->get();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
						<p class="note">
							Leaf descendants are returned in order of their position in the tree.
						</p>
					</article>

					<article>
						<h4 id="method_get_siblings" class="method">siblings()</h4>
						<p>
							The <strong>siblings</strong> method allows you to get all sibling nodes of the object you call this method on.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the siblings of $kerry
$siblings = $kerry->siblings()->get();

// echos 'true'
echo $siblings == array($kerry->id => $kerry, $james->id => $james) ? 'true' : 'false';

// returns null, it won't work without a current node context
$parent = Model_Tree::forge()->siblings()->get();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
						<p class="note">
							Siblings are returned in order of their position in the tree. Note that the result set will include the current node!
						</p>
					</article>

					<article>
						<h4 id="method_get_child" class="method">child()</h4>
						<p>
							The <strong>child</strong> method is an alias for the <a href="#method_get_last_child">last_child</a> method.
						</p>
					</article>

					<article>
						<h4 id="method_get_first_child" class="method">first_child()</h4>
						<p>
							The <strong>first_child</strong> method allows you to get the first child node of the object you call this method on.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the first child of $bill
$child = $bill->first_child()->get_one();

// echos 'true'
echo $child == $angela ? 'true' : 'false';

// returns null, it won't work without a current node context
$parent = Model_Tree::forge()->first_child()->get_one();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_get_last_child" class="method">last_child()</h4>
						<p>
							The <strong>last_child</strong> method allows you to get the last child node of the object you call this method on.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the last child of $bill
$child = $bill->last_child()->get_one();

// echos 'true'
echo $child == $ben ? 'true' : 'false';

// returns null, it won't work without a current node context
$parent = Model_Tree::forge()->last_child()->get_one();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_get_sibling" class="method">sibling()</h4>
						<p>
							The <strong>sibling</strong> method is an alias for the <a href="#method_get_next_sibling">next_sibling</a> method.
						</p>
					</article>

					<article>
						<h4 id="method_get_previous_sibling" class="method">previous_sibling()</h4>
						<p>
							The <strong>previous_sibling</strong> method allows you to get the previous_sibling node of the object you call this method on.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the previous sibling of $nicola
$sibling = $nicola->previous_silbing()->get_one();

// echos 'true'
echo $sibling == $henry ? 'true' : 'false';

// returns null, it won't work without a current node context
$parent = Model_Tree::forge()->previous_sibling()->get_one();

// will return null too, $henry has no previous sibling
$sibling = $henry->previous_silbing()->get_one();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_get_next_sibling" class="method">next_sibling()</h4>
						<p>
							The <strong>next_sibling</strong> method allows you to get the next sibling node of the object you call this method on.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the next sibling of $henry
$sibling = $henry->next_silbing()->get_one();

// echos 'true'
echo $sibling == $nicola ? 'true' : 'false';

// returns null, it won't work without a current node context
$parent = Model_Tree::forge()->previous_sibling()->get_one();

// will return null too, $nicola has no previous sibling
$sibling = $nicola->next_silbing()->get_one();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_get_path" class="method">path($addroot = true)</h4>
						<p>
							The <strong>path</strong> method returns the path to the current node as a string, using the column identified
							by the "title_field" in the models tree configuration.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$addpath</kbd></th>
												<td><pre class="php"><span class="keyword">true</span></pre></td>
												<td>If false, the root node will be excluded from the result.</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Throws</th>
									<td>OutOfBoundsException, if the model doesn't define a "title_field" column.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the path to Tim, returns "Bill/Ben/Kerry/Tim"
$path = $tim->path()->get();

// get the path to Nicola, returns "Bill/Angela/Nicola"
$path = $nicola->path()->get();

// get the path to Kerry, and exclude the boss. returns "Ben/Kerry"
$path = $kerry->path(false)->get();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<h3 id="collection_methods_save">Collection methods for saving nodes</h3>

					<p>
						Like with a standard ORM model, <strong>save()</strong> will either insert the object as a new record in the table,
						or it updates an existing record in case the object was retrieved from the database.
					</p>
					<p>
						However, unlike a standard ORM model in a nestedset tree is is very relevant <u>where</u> exactly in the tree an object
						is saved. If you don't specify a collection method before save, saving an existing object will just do that, identical to
						normal ORM model behaviour. If you did specify a collection method, the object will be relocated in the tree when you save.
						If your saving a new object, not specifing a collection method will create a new root node. If you did specify one, it will
						determine where in the tree the new node will be inserted.
					</p>

					<article>
						<h4 id="method_save_child" class="method">child($to = null)</h4>
						<p>
							The <strong>child</strong> method is an alias for the <a href="#method_save_last_child">last_child</a> method.
						</p>
					</article>

					<article>
						<h4 id="method_save_first_child" class="method">first_child($to = null)</h4>
						<p>
							The <strong>first_child</strong> method tells the model you want to save the object you call this method on
							as the first child of the (primary key of the) node object passed.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$to</kbd></th>
												<td><pre class="php"><span class="keyword">null</span></pre></td>
												<td>The node object or the primary key of the node which has to become the parent of the object on which this method is called.</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// give bill a new subordinate, before Angela in the tree
$john = Model_Tree::forge(array('name' => 'John'))->first_child($bill)->save();

// promote Kerry to a subordinate of Bill
$kerry->first_child($bill)->save();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_save_last_child" class="method">last_child($to = null)</h4>
						<p>
							The <strong>last_child</strong> method tells the model you want to save the object you call this method on
							as the last child of the (primary key of the) node object passed.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$to</kbd></th>
												<td><pre class="php"><span class="keyword">null</span></pre></td>
												<td>The node object or the primary key of the node which has to become the parent of the object on which this method is called.</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// give bill a new subordinate, after Ben in the tree
$john = Model_Tree::forge(array('name' => 'John'))->last_child($bill)->save();

// promote Kerry to a subordinate of Bill
$kerry->last_child($bill)->save();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<p class="note">
						From a hierarchy perspective, <strong>first_child</strong> and <strong>last_child</strong> do the same. Only the
						exact position in the tree, the relation to its siblings after the insert or relocation of the node, is different.
					</p>

					<article>
						<h4 id="method_save_sibling" class="method">sibling($to = null)</h4>
						<p>
							The <strong>sibling</strong> method is an alias for the <a href="#method_save_next_sibling">next_sibling</a> method.
						</p>
					</article>

					<article>
						<h4 id="method_save_previous_sibling" class="method">previous_sibling($to = null)</h4>
						<p>
							The <strong>previous_sibling</strong> method tells the model you want to save the object you call this method on
							as the previous sibling of the (primary key of the) node object passed (just before the passed object, on the same level in the tree).
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$to</kbd></th>
												<td><pre class="php"><span class="keyword">null</span></pre></td>
												<td>The node object or the primary key of the node which has to become the next sibling of the object on which this method is called.</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// give bill a new subordinate, before Angela in the tree
$john = Model_Tree::forge(array('name' => 'John'))->previous_sibling($angela)->save();

// demote James to be a subordinate of Ben, besides Tim
$james->previous_sibling($tim)->save();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_save_next_sibling" class="method">next_sibling($to = null)</h4>
						<p>
							The <strong>next_sibling</strong> method tells the model you want to save the object you call this method on
							as the next sibling of the (primary key of the) node object passed (just after the passed object, on the same level in the tree).
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$to</kbd></th>
												<td><pre class="php"><span class="keyword">null</span></pre></td>
												<td>The node object or the primary key of the node which has to become the previous sibling of the object on which this method is called.</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// give bill a new subordinate, after Angela in the tree
$john = Model_Tree::forge(array('name' => 'John'))->next_sibling($angela)->save();

// demote James to be a subordinate of Ben, besides Tim
$james->next_sibling($tim)->save();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

                </section>

                <section>
					<h2 id="test_methods">テストメソッド</h2>

					<p>
						Test methods are used to query a particular state of the object with regards to their position in the tree.
					</p>

					<article>
						<h4 id="method_is_root" class="method">is_root()</h4>
						<p>
							The <strong>is_root</strong> method tells you if the object you're calling it on is a root node or not.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Bool, true if the object is a root node, false if not</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// is Bill a root node? echo's 'true'
echo $bill->is_root() ? 'true' : 'false';

// is Tim a root node? echo's 'false'
echo $tim->is_root() ? 'true' : 'false';
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_is_leaf" class="method">is_leaf()</h4>
						<p>
							The <strong>is_leaf</strong> method tells you if the object you're calling it on is a leaf, i.e. that is doesn't have child nodes.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Bool, true if the object is a leaf node, false if not</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// is Tim a leaf node? echo's 'true'
echo $tim->is_leaf() ? 'true' : 'false';

// is Angela a leaf node? echo's 'false'
echo $angela->is_leaf() ? 'true' : 'false';
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_is_child" class="method">is_child()</h4>
						<p>
							The <strong>is_child</strong> method tells you if the object you're calling it on is a child node, i.e. that is has
							a parent node. This is the reverse of <strong>is_root()</strong>, as all non-root nodes have a parent.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Bool, true if the object is a child node, false if not</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// is Henry a root node? echo's 'true'
echo $henry->is_child() ? 'true' : 'false';

// is Bill a root node? echo's 'false'
echo $bill->is_child() ? 'true' : 'false';
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_is_child_of" class="method">is_child_of(Model_Nestedset $to = null)</h4>
						<p>
							The <strong>is_child_of</strong> method allows you to check if the object you call this method on
							is a child node (a direct descendant) of the node object passed.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$to</kbd></th>
												<td><pre class="php"><span class="keyword">null</span></pre></td>
												<td>The node which you want to check against.</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Bool, true if the object is a child node of the node passed, false if not</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// is Ben a child node of Bill? echo's 'true'
echo $ben->is_child_of($bill) ? 'true' : 'false';

// is James a child node of Bill? echo's 'false', as it's a grandchild
echo $james->is_child_of($bill) ? 'true' : 'false';

// is Nicola a child node of Ben? echo's 'false', different part of the tree
echo $nicola->is_child_of($ben) ? 'true' : 'false';
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_is_descendant_of" class="method">is_descendant_of(Model_Nestedset $to = null)</h4>
						<p>
							The <strong>is_descendant_of</strong> method allows you to check if the object you call this method on
							is a descendant node of the node object passed.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$to</kbd></th>
												<td><pre class="php"><span class="keyword">null</span></pre></td>
												<td>The node which you want to check against.</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Bool, true if the object is a descendant node of the node passed, false if not</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// is Ben a descendant node of Bill? echo's 'true'
echo $ben->is_descendant_of($bill) ? 'true' : 'false';

// is James a descendant node of Bill? echo's 'true', as it's a grandchild
echo $james->is_descendant_of($bill) ? 'true' : 'false';

// is Nicola a descendant node of Ben? echo's 'false', different part of the tree
echo $nicola->is_descendant_of($ben) ? 'true' : 'false';
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>


					<article>
						<h4 id="method_is_parent_of" class="method">is_parent_of(Model_Nestedset $to = null)</h4>
						<p>
							The <strong>is_parent_of</strong> method allows you to check if the object you call this method on
							is the parent node of the node object passed.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$to</kbd></th>
												<td><pre class="php"><span class="keyword">null</span></pre></td>
												<td>The node which you want to check against.</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Bool, true if the object is the parent node of the node passed, false if not</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// is Bill the parent of Ben? echo's 'true'
echo $bill->is_parent_of($ben) ? 'true' : 'false';

// is Bill the parent of James? echo's 'false', as it's a grandparent
echo $bill->is_parent_of($james) ? 'true' : 'false';
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_is_ancestor_of" class="method">is_ancestor_of(Model_Nestedset $to = null)</h4>
						<p>
							The <strong>is_ancestor_of</strong> method allows you to check if the object you call this method on
							is a ancestor of the node object passed.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$to</kbd></th>
												<td><pre class="php"><span class="keyword">null</span></pre></td>
												<td>The node which you want to check against.</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Bool, true if the object is an ancestor of the node passed, false if not</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// is Bill an ancestor of Ben? echo's 'true'
echo $bill->is_ancestor_of($ben) ? 'true' : 'false';

// is Bill an ancestor of James? echo's 'true', as it's a grandparent
echo $bill->is_ancestor_of($james) ? 'true' : 'false';
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_is_same_model_as" class="method">is_same_model_as(Model_Nestedset $to = null)</h4>
						<p>This method is mainly used internally to avoid operations across two different Nestedset models.</p>
					</article>

					<article>
						<h4 id="method_is_same_tree_as" class="method">is_same_tree_as(Model_Nestedset $to = null)</h4>
						<p>
							This method is mainly used internally to avoid operations across two different Nestedset models.
							It not only checks if both objects are instances of the same model, but also if both instances belong
							to the same tree in a multi-tree model.
						</p>
					</article>

					<article>
						<h4 id="method_has_parent" class="method">has_parent()</h4>
						<p>
							The <strong>has_parent</strong> method is an alias for the <a href="#method_is_child">is_child</a> method.
						</p>
					</article>

					<article>
						<h4 id="method_has_children" class="method">has_children()</h4>
						<p>
							The <strong>has_children</strong> method is the reverse of the <a href="#method_is_leaf">is_leaf</a> method.
							If an object is not a leaf, it implies it has child nodes.
						</p>
					</article>

					<article>
						<h4 id="method_has_previous_sibling" class="method">has_previous_sibling()</h4>
						<p>
							The <strong>has_previous_sibling</strong> method tells you if the object you're calling it on has a previous sibling.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Bool, true if the object has a previous sibling, false if not</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// Does James have a previous sibling? echo's 'true'
echo $james->has_previous_sibling() ? 'true' : 'false';

// Does Tim have a previous sibling? echo's 'false'
echo $tim->has_previous_sibling() ? 'true' : 'false';
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_has_next_sibling" class="method">has_next_sibling()</h4>
						<p>
							The <strong>has_next_sibling</strong> method tells you if the object you're calling it on has a next sibling.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Bool, true if the object has a next sibling, false if not</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// Does Henry have a next sibling? echo's 'true'
echo $henry->has_next_sibling() ? 'true' : 'false';

// Does Ben have a next sibling? echo's 'false'
echo $ben->has_next_sibling() ? 'true' : 'false';
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>
                </section>

                <section>
					<h2 id="miscellaneous_methods">その他のメソッド</h2>

					<article>
						<h4 id="method_delete_tree" class="method">delete_tree($cascade = null, $use_transaction = false)</h4>
						<p>
							The <kbd>delete_tree</kbd> works identical to the <a href="#method_delete">delete()</a> method, which the difference that
							this method DOES delete all children as well.
						</p>
						<p class="note">
							If you use the <strong>delete_tree()</strong> method on a root node, the entire tree will be deleted!
						</p>
					</article>

					<article>
						<h4 id="method_tree_config" class="method">tree_config($name = null)</h4>
						<p>
							You use this method to get one or all tree configuration options of the model. It is mainly used internally
							to construct queries that operate on parts of the tree, or on a specific tree in a multi-tree model.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>Yes</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$name</kbd></th>
												<td><pre class="php"><span class="keyword">null</span></pre></td>
												<td>The name of the configuration property to return.</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>A configuration value, an array of values, or null if the requested value does not exist.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the name of the tree-id column
$tree_id = Model_Tree::tree_config('tree_id');</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_get_tree_id" class="method">get_tree_id()</h4>
						<p>
							You use this method to get the tree-id in a multi-tree environment. If there is a valid node to operate on, the
							tree-id of that node is returned. If not, the value set using <strong>set_tree_id()</strong> is returned.
							If no tree-id has been set, an exception is thrown. This method is mainly used internally to make sure queries
							run in the context of the current tree in a multi-tree environment.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>mixed, the tree-id of the current tree, or the default tree-id set.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the tree_id (returns 1)
$current_tree = $bill->get_tree_id();</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_set_tree_id" class="method">set_tree_id($tree = null)</h4>
						<p>
							You use this method to set the tree-id in a multi-tree environment. You mainly use this when you want to
							run	a <strong>get()</strong> or <strong>get_one()</strong> but you don't have an existing node to work on.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$tree</kbd></th>
												<td><pre class="php"><span class="keyword">null</span></pre></td>
												<td>The tree-id of the tree to select. If no value, or null, is passed, the stored tree-id is reset.</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get the root of a tree without having a previous node to work with
$root = Model_Tree::forge()->set_tree_id($mytreeid)->get_one();</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_build_query" class="method">build_query()</h4>
						<p>
							The <strong>build_query</strong> method returns an ORM query object, like <strong>Model_Nestedset::query()</strong>
							but with an added <strong>where</strong> clause in case of a multi-tree model, to make sure the query runs in the context of the
							current tree. It requires a tree-id to be available, so if you call this on a new object, use <strong>set_tree_id</strong> to make
							sure a valid id is defined.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>an ORM Query object.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get all nodes in the current tree with an enabled status set
$enabled = Model_Tree::forge()
	->set_tree_id($mytreeid)
	->build_query()
	->where('enabled', '=', 1)
	->get();

// using an existing object, this will use the tree-id of the $bill object
$enabled = $bill
	->build_query()
	->where('enabled', '=', 1)
	->get();</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_get_query" class="method">get_query()</h4>
						<p>
							The <strong>get_query</strong> method returns an ORM query object, but unlike <strong>build_query()</strong>
							this method requires a collection methods to be used. It allows you to use the standard Model methods to
							constuct a first selection of nodes, and use the returned Query object to fine-tune the query.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>an ORM Query object.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// get all child nodes of Bill with an enabled status set
$enabled = $bill
	->children()
	->get_query()
	->where('enabled', '=', 1)
	->get();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_count_children" class="method">count_children()</h4>
						<p>
							The <strong>count_children</strong> method returns the number of children (direct descendants) of the object you're calling it on.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Integer</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// Get the number of Bill's children, echo's 2
echo $bill->count_children();

// Get the number of Kerry's children, echo's 1
echo $kerry->count_children();

// Get the number of Tim's children, echo's 0
echo $tim->count_children();

// echo's 0 too, a new object can't have children
echo Model_Tree::forge()->count_children();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_count_descendants" class="method">count_descendants()</h4>
						<p>
							The <strong>count_descendants</strong> method returns the number of descendants of the object you're calling it on.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Integer</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// Get the number of Bill's descendants, echo's 7
echo $bill->count_descendants();

// Get the number of Ben's children, echo's 3
echo $ben->count_descendants();

// echo's 0, a new object can't have descendants
echo Model_Tree::forge()->count_descendants();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_depth" class="method">depth()</h4>
						<p>
							The <strong>depth</strong> method returns the depth or level the current node is in the tree, where
							the level of the root node is 0.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										None.
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Mixed, integer or false if the current object is not valid</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// Get the level of Bill in the organisation
echo $bill->depth(); // echo's 0, he's top dog!

// Get the level of Angela in the organisation
echo $angela->depth(); // echo's 1, as she's an N+1

// Get the level of Tim in the organisation
echo $tim->depth(); // echo's 3, as low as you can go...

// returns false, you can't get the depth of a new node
$result = Model_Tree::forge()->depth();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
					</article>

					<article>
						<h4 id="method_dump_tree" class="method">dump_tree($as_object = false, $children = 'children', $path = 'path')</h4>
						<p>
							The <strong>dump_tree</strong> method returns the entire tree, using the current object as root node
							into a multi-dimensional array.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$as_object</kbd></th>
												<td><pre class="php"><span class="keyword">false</span></pre></td>
												<td>If true, it will return a hierarchical tree of objects instead of a multi-dimensional array.</td>
											</tr>
											<tr>
												<th><kbd>$children</kbd></th>
												<td><pre class="php">'children'</pre></td>
												<td>data for child nodes will be added to a property or array key with this name.</td>
											</tr>
											<tr>
												<th><kbd>$path</kbd></th>
												<td><pre class="php">'path'</pre></td>
												<td>
													a property by this name is created and will contain the path to the node, starting at the root.
													This requires the 'title_field' to be configured!
												</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Mixed, multi-dimensional array, or the current object, with added children.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// returns a multi-dimensional array. $tree['children'] will contain the children of Bill
$tree = $bill->dump_tree();

// returns the 'bill' object with a property 'children' containing the children of Bill
$tree = $bill->dump_tree(true);

// using $tree, this returns array($angela, $ben)
$children = $tree->children;

// and this returns array($henry, $nicola), the children of $angela
$grandchildren = reset($children)->children;

// ORM objects are always used by reference!
$bill->dump_tree(true);

// so this works fine too...
$children = $bill->children;
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
						<p class="note">
							As with all ORM array's, the table's primary key is used as array index. Note that because the ORM uses objects by
							reference from a single cache, if you choose to use 'as_object', children will be added to existing objects too.</p>
					</article>

					<article>
						<h4 id="method_related" class="method">related($relation, $conditions = array())</h4>
						<p>
							The <strong>related</strong> method allows you to fetch related objects when executing a nested set command, indentical
							to a normal Orm model query.
						</p>
						<table class="method">
							<tbody>
								<tr>
									<th class="legend">Static</th>
									<td>No</td>
								</tr>
								<tr>
									<th>Parameters</th>
									<td>
										<table class="parameters">
											<tr>
												<th>Param</th>
												<th>Default</th>
												<th class="description">Description</th>
											</tr>
											<tr>
												<th><kbd>$related</kbd></th>
												<td><pre class="php">required</pre></td>
												<td>The name of the relation to include.</td>
											</tr>
											<tr>
												<th><kbd>$conditions</kbd></th>
												<td><pre class="php">array()</pre></td>
												<td>Any conditions you want to pass on when fetching the related objects.</td>
											</tr>
										</table>
									</td>
								</tr>
								<tr>
									<th>Returns</th>
									<td>Model_Nestedset, for chaining.</td>
								</tr>
								<tr>
									<th>Example</th>
									<td>
										<pre class="php"><code>// include related 'child' objects in the result
$tree = $bill->related('child')->dump_tree();

// get the descendants of $ben
$descendants = $ben->descendants()->related('child')->get();

// This will NOT include the child relation!
$descendants = $ben->related('child')->descendants()->get();
</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
						<p class="note">
							If you want to use this method on any nested set operation (like for example decendants()), make sure to setup that
							operation first. If you don't, your included relations will be reset my the nested set operation method call!</p>
					</article>
                </section>
			</div>
		<footer>
			<p>
				&copy; FuelPHP Development Team 2010-2015 - <a href="http://fuelphp.com">FuelPHP</a> is released under the MIT license.
[ <a href="https://github.com/fuel/docs/commits/1.8/develop/packages/orm/model/nestedset.html">原文コミット履歴</a> | <a href="https://github.com/NEKOGET/FuelPHP_docs_jp/commits/1.8/develop_japanese/packages/orm/model/nestedset.html">翻訳コミット履歴</a> | <a href="https://github.com/NEKOGET/FuelPHP_docs_jp/blob/1.8/develop_japanese/packages/orm/model/nestedset.html">GitHubで修正</a> ]
			</p>
		</footer>
	</div>
</body>
</html>

<!doctype html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="./../../assets/css/combined.css">
	<link rel="shortcut icon" href="./../../favicon.ico" />
	<script src="http://www.google.com/jsapi" type="text/javascript"></script>
	<script type="text/javascript">
		var path = './../../';
		var class_prefix = "Session::";
	</script>
	<script src="./../../assets/js/combined.js"></script>
	<title>Session 高度な使い方 - クラス - FuelPHP ドキュメント</title>
</head>
<body>
	<div id="container">
		<header id="header">
			<div class="table">
				<h1>
					<strong>FuelPHP, a PHP 5.3 Framework</strong>
					Documentation
				</h1>

				<form id="google_search">
					<p>
						<span id="search_clear">&nbsp;</span>
						<input type="submit" name="search_submit" id="search_submit" value="検索" />
						<input type="text" value="" id="search_input" name="search_input" />
					</p>
				</form>
			</div>
			<nav>

				<div class="clear"></div>
			</nav>
			<a href="#" id="toc_handle">目次</a>
			<div class="clear"></div>
		</header>

		<div id="cse">
			<div id="cse_point"></div>
			<div id="cse_content"></div>
		</div>

		<div id="main">

			<h2>Session クラス</h2>

			<p>セッションクラスを使用することでステートレスな Web 環境において、アプリケーションの状態を管理出来るようになります。
				サーバー上の様々なストレージに変数を格納し、それらを次のページリクエストに再度呼び出すことが出来ます。</p>

			<h3 id="manual_loading">手動読み込み</h3>

			<p>
				ほとんどの場合、<a href="./usage.html">使用法</a>ページの記載で十分目的のドライバを設定し、メソッドを利用することができます。
				しかしながら、セッションが振る舞う方法をより詳細に制御したい状況があるでしょう。
				セッション設定ファイルで設定されている別のセッションドライバを利用する場合があります。
				もしくは、同時に複数のドライバを必要としています。 それは <kbd>forge</kbd> メソッドの出番です。
			</p>
			<p>
				<kbd>forge</kbd> メソッドは設定ファイルまたはパラメータで定義されたドライバを利用し、セッションクラスのインスタンスを返します。
				動的呼び出しを利用し、<a href="./usage.html">使用法</a>ページの記載されたメソッドで返されたオブジェクトで利用することができます。
			</p>

			<article>
				<h4 class="method" id="method_forge">forge($config = array())</h4>
				<p>
					<strong>forge</strong> メソッドは、セッションドライバを手動でインスタンス化することができます。
				</p>
				<table class="method">
					<tbody>
					<tr>
						<th>静的</th>
						<td>はい</td>
					</tr>
					<tr>
						<th>パラメータ</th>
						<td>
							<table class="parameters">
								<tr>
									<th>パラメータ</th>
									<th>デフォルト</th>
									<th>説明</th>
								</tr>
								<tr>
									<th><kbd>$config</kbd></th>
									<td><i>任意</i></td>
									<td>
										forge メソッドに単にドライバの名前を渡すことで希望のドライバを選択することができます。
										より多くのカスタム設定が必要な場合は、<a href="./config.html">設定</a>ページに記載されたパラメータを利用し、 $config 配列を定義します。
										ここに渡す設定は設定ファイルで定義された内容を上書きします。
									</td>
								</tr>
							</table>
						</td>
					</tr>
					<tr>
						<th>返り値</th>
						<td>オブジェクト - セッションオブジェクトのインスタンス</td>
					</tr>
					<tr>
						<th>例</th>
						<td>
							<pre class="php"><code>// データベースセッションをインスタンス化
$session = Session::forge('db');

// セッションからカウンターを取得
$counter = $session->get('counter');

// 存在しない場合、デフォルトを設定
if ($counter === false)
{
	$counter = 0;
}

// カウンターを書き込む
$session->set('counter', $counter);

// Fuel はその処理をするので、明示的に記述する必要はありません...

// また、設定ファイル内のデフォルト値を上書きする設定でドライバをロードすることが可能
$session = Session::forge( array('driver' => 'memcached', 'expiration_time' => 3600, 'memcached' = array('cookie_name' => 'appcookie')) );
</code></pre>
						</td>
					</tr>
					</tbody>
				</table>

				<p class="note">
					<kbd>ご注意：</kbd> あなたは、同時に複数のセッションドライバを利用する場合、これらのドライバの各インスタンスの <kbd>cookie_name</kbd> は一意である必要があります。
					既に利用している <kbd>cookie_name</kbd> を利用しドライバを読み込もうとして、それを利用してインスタンスをロードしようとしているのと同じドライバを利用している場合、そのインスタンスが再利用されます。
					インスタンスが別のドライバを使用している場合、例外がスローされます。
				</p>

			</article>

			<article>
				<h4 class="method" id="method_rotate">rotate()</h4>
				<p>
					<strong>rotate</strong> メソッドは手動でのセッション id のローテーションをユーザが強制することができます。 例えば、現在のユーザーのセキュリティレベルが変更されたとき、などに追加のセキュリティ対策としてこれを使用することができます。
				</p>
				<table class="method">
					<tbody>
					<tr>
						<th>静的</th>
						<td>いいえ</td>
					</tr>
					<tr>
						<th>パラメータ</th>
						<td>
							なし
						</td>
					</tr>
					<tr>
						<th>返り値</th>
						<td>なし</td>
					</tr>
					<tr>
						<th>例</th>
						<td>
							<pre class="php"><code>// データベースセッションをインスタンス化
$session = Session::forge('db');

// 強制的にセッション id のローテーション
$session->rotate();
</code></pre>
						</td>
					</tr>
					</tbody>
				</table>

			</article>

			<article>
				<h4 class="method" id="method_get_config">get_config()</h4>
				<p>
					<strong>get_config</strong> メソッドはセッションドライバ設定項目を取得することができます。
				</p>
				<table class="method">
					<tbody>
					<tr>
						<th>静的</th>
						<td>いいえ</td>
					</tr>
					<tr>
						<th>パラメータ</th>
						<td>
							<table class="parameters">
								<tr>
									<th>パラメータ</th>
									<th>デフォルト</th>
									<th>説明</th>
								</tr>
								<tr>
									<th><kbd>$name</kbd></th>
									<td><i>必須</i></td>
									<td>
										セッション設定の変数の名前。
									</td>
								</tr>
							</table>
						</td>
					</tr>
					<tr>
						<th>返り値</th>
						<td>mixed 、要求された値、または、要求された変数が存在しないことを示す null</td>
					</tr>
					<tr>
						<th>例</th>
						<td>
							<pre class="php"><code>// データベースセッションをインスタンス化
$session = Session::forge('db');

// 定義されたセッションクッキー名を取得
$cookiename = $session->get_config('cookie_name');
</code></pre>
						</td>
					</tr>
					</tbody>
				</table>

			</article>

			<article>
				<h4 class="method" id="method_set_config">set_config()</h4>
				<p>
					<strong>set_config</strong> メソッドは実行時にセッションドライバの設定項目を変更することができます。
				</p>
				<table class="method">
					<tbody>
					<tr>
						<th>静的</th>
						<td>いいえ</td>
					</tr>
					<tr>
						<th>パラメータ</th>
						<td>
							<table class="parameters">
								<tr>
									<th>パラメータ</th>
									<th>デフォルト</th>
									<th>説明</th>
								</tr>
								<tr>
									<th><kbd>$name</kbd></th>
									<td><i>必須</i></td>
									<td>
										セッション設定の変数の名前。
									</td>
								</tr>
							</table>
						</td>
					</tr>
					<tr>
						<th>返り値</th>
						<td>なし</td>
					</tr>
					<tr>
						<th>例</th>
						<td>
							<pre class="php"><code>// データベースセッションをインスタンス化
$session = Session::forge('db');

// このセッションの有効期限を 2 時間後に設定
$session->set_config('expiration_time', 7200);
</code></pre>
						</td>
					</tr>
					</tbody>
				</table>

			</article>

			<h2>Flash とセッションの使い方</h2>

			<p>
				ウェブサイトで Flash オブジェクトを利用する問題点の一つは、彼らがあなたのウェブアプリケーションと対話するとき、ブラウザに保存されているクッキーを送信しないことです。
				この問題が原因で、アプリケーションのセッション状態を認識させることは困難となります。
			</p>

			<p>
				この問題を解決するために、セッションクラスは、 POST 変数を利用しアプリケーションにクッキーを渡すことができます。
				'post_cookie_name' 設定を利用し変数の名前を設定することができます。 Session クラスは、 $_POST
				変数にこの名前を見つけた場合、それにセッションクッキーが含まれていると仮定し、セッションクッキーを使用しません。
				これは少しの JavaScript を利用してセッションクッキーのクライアントサイドの内容を POST 変数にコピーすることができます。
			</p>

			<p class="note">
				Flash ベースのアップローダ利用時。 <kbd>match_ua</kbd> 設定を <kbd>false</kbd> に設定する必要があります。
				Flash が異なるユーザーエージェントを使用しているためこれを行う必要があり、これはユーザセッションを正しく識別するために
				Session クラスの (訳注：動きを) 防ぐことができます。
			</p>

							<pre class="javascript"><code>// セッションクッキーを取得する関数
// あなたが利用したり、所有している、または用意した好きな javascript のフレームワークを利用できます。
function getCookie(c_name)
{
	if (document.cookie.length > 0)
	{
		c_start = document.cookie.indexOf(c_name + "=");

		if (c_start != -1)
		{
			c_start = c_start + c_name.length + 1;
			c_end = document.cookie.indexOf(";", c_start);
			if (c_end == -1) c_end = document.cookie.length;
			return unescape(document.cookie.substring(c_start, c_end));
		}
	}

	return "";
}

// この例では jquery と uploadify を使用しており、 'fuelcid' として formData で
// Fuel のクッキー (ここでは 'fuelcid' と呼ぶ) を渡している。

// 注意：このコードを生成するとき、クッキー名をハードコードせず、その代わりに、
// セッション設定ファイルからクッキー名を取得してください。

// 注意:: あなたが戻ってセッションIDを渡すために利用可能なクッキーを持っていない場合は
// 下記のセクション "クッキーなしのセッション" をチェックしてください。

// ( パラメータは Uploadify Version 3.2 に関連している )

$(function()
{
	$('#custom_file_upload').uploadify(
	{
		'swf'            : '/uploadify/uploadify.swf',
		'uploader'       : '/uploadify/uploadify.php',
		'multi'          : true,
		'auto'           : true,
		'fileTypeExts'   : '*.jpg;*.gif;*.png',
		'fileTypeDesc'   : 'Image Files (.JPG, .GIF, .PNG)',
		'queueID'        : 'custom-queue',
		'queueSizeLimit' : 3,
		'removeCompleted': false,
		'formData'       : {'fuelcid': getCookie('fuelcid')},
		'onSelect'       : function(file)
		{
			alert('The file ' + file.name + ' was added to the queue.');
		},
		'onQueueComplete' : function(queueData)
		{
			alert(queueData.uploadsSuccessful + ' files were successfully uploaded.');
		}
	});
}
</code></pre>

			<h3 id="concurrency">並行性</h3>

			<p>
				セッション、セッションクッキー、およびそれらの挙動について話したとき、それは彼らはどのように動作するか
				そして可能性と制限があることを理解することが重要です。
			</p>
			<p>
				これは同時に実行される場合に特にあてはまります。
				ウェブベースのアプリケーションでは、ウェブページ上で複数の非同期 ajax 呼び出しを利用している場合、または同じアプリケーションの複数のウィンドウを開くこと
				(これは、受け入れましょう、あなたが防ぐことができないものです) をブラウザが許可した場合に、並行性を持つことになります。
			</p>
			<p>
				Something else you need to know is that by default, the session class will rotate (or regenerate) the session id on a regular basis,
				to prevent session hijacking due to session id fixation (someone stealing your session cookie and use it to take over your session).
				You can control the rotation time using a configuration setting, or even disable it, but from a security point of view that is a bad idea.
				Take these two together, and you have a potential disaster on your hands!
			</p>
			<p>
				An illustration:<br />
				- you request a page, the session cookie containing ID-A is sent to the server.<br />
				- your page sends two ajax requests. the session cookie containing ID-A is again sent to the server with each request.<br />
				- ajax request 1 finishes, and rotates the ID. A cookie with ID-B is sent to the browser.<br />
				- now ajax request 2 finishes. Because it sent the same cookie, it also decides to rotate, this time to ID-C.<br />
				(you will get a different ID, because session IDs are generated using a randomized algorithm)<br />
			</p>
			<p>
				Now we have a problem. The session class tries to update the stored session with key ID-A to ID-C, but it can't find that session.
				Remember, it had been updated from ID-A to ID-B by the first ajax call! So it decides the session is invalid, create a new and empty
				session, and return that cookie to the browser. Now your valid cookie is overwritten by the new and empty session cookie.
				Result: you have lost the session.
			</p>
			<p>
				This is an issue that most frameworks have not solved. Enter Fuel!
			</p>
			<p>
				Fuel's session class contains two mechanisms to detect and mitigate this problem.
				Every session key store contains two session IDs: the current ID and the previous ID.
				If a request comes in just after the session id has been rotated, the correct session can be located using the previous session id stored in the key store.
				And it case of a session id mismatch which could not be recovered using the previous id, no updated cookie will be sent back to the browser.
				The result is that you lose the session data of that request, but you don't lose the session itself.
			</p>

			<h3 id="no-cookies">クッキーなしのセッション</h3>

			<p>
				After a change to the session data, the Session class will always generate a session cookie, and send it to the client in the HTTP
				response header. However, there are situations where is it undesireable, of even impossible, to use cookies. For example simply
				because the client does not support them.
			</p>
			<p>
				In these cases, there are alternative ways to pass a Session ID back to the application on a request from the client:
			</p>

			<ul>
				<li>via a <strong>GET</strong> variable. The name of the variable in the URL must be equal to the name of the cookie defined in the configuration.</li>
				<li>via a <strong>POST</strong> variable. You can define the form field name (post_cookie_name) that contains the session-id in the configuration.</li>
				<li>via the <strong>HTTP header</strong>. When constructing the HTTP request client side, you can add a "Session-Id" HTTP header with the session id.</li>
			</ul>

			<p>
				You can use <code>Session::key()</code> to retrieve the current session id, so you can pass it to the client in the response, instead
				of using a cookie. If you have configured encryption in your session configuration, you need to encrypt the id:
			</p>

			<pre class="php"><code>// fetch the session ID and encrypt it
$session_id = \Crypt::encode(\Session::key());
</code></pre>

		</div>

		<footer>
			<p>
				&copy; FuelPHP Development Team 2010-2015 - <a href="http://fuelphp.com">FuelPHP</a> is released under the MIT license.
[ <a href="https://github.com/fuel/docs/commits/1.8/develop/classes/session/advanced.html">原文コミット履歴</a> | <a href="https://github.com/NEKOGET/FuelPHP_docs_jp/commits/1.8/develop_japanese/classes/session/advanced.html">翻訳コミット履歴</a> | <a href="https://github.com/NEKOGET/FuelPHP_docs_jp/blob/1.8/develop_japanese/classes/session/advanced.html">GitHubで修正</a> ]
			</p>
		</footer>
	</div>
</body>
</html>
